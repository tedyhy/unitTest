<!DOCTYPE html>
<html>

<head>
	<title>Dom</title>
	<link rel="stylesheet" href="../codemirror/lib/codemirror.css">
	<script src="../codemirror/lib/codemirror.js"></script>
	<script src="../codemirror/mode/javascript/javascript.js"></script>
	<script src="../codemirror/mode/xml/xml.js"></script>
	<script src="../codemirror/mode/htmlmixed/htmlmixed.js"></script>
	<style type="text/css">
		.CodeMirror {
			height: auto;
		}
	</style>
</head>

<body>
<h1>Dom</h1>
<p>
	IE中所有DOM对象都是以COM对象的形式实现的。IE中的DOM对象与原生的JavaScript对象的行为或活动特点并不一致。
</p>
<h2>节点层次</h2>
<p>
	DOM可以将任何HTML/XML文档描绘成一个由多层节点构成的结构。<br>
	文档节点（Document节点）是每个文档的根节点。<br>
	&lt;html&gt;元素是文档元素，文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。<br>每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是&lt;html&gt;元素，在XML中，任何元素都可能成为文档元素。<br>
</p>
<h4>Node类型</h4>
<p>
	DOM1级定义了一个Node接口，该接口由DOM中的所有节点类型实现。<br>
	这个Node接口在JavaScript中是作为Node类型实现的；除了IE外，其他所有浏览器中都可以访问到这个类型。<br>
	JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。<br>
	每个节点都有一个nodeType属性，用于表明节点类型。共有12种节点类型：
</p>
<textarea class="codemirror">
/*
1.Node.ELEMENT_NODE(1);
2.Node.ATTRIBUTE_NODE(2);
3.Node.TEXT_NODE(3);
4.Node.CDATA_SECTION_NODE(4);
5.Node.ENTITY_REFERENCE_NODE(5);
6.Node.ENTITY_NODE(6);
7.Node.PROCESSING_INSTRUCTION_NODE(7);
8.Node.COMMENT_NODE(8);
9.Node.DOCUMENT_NODE(9);
10.Node.DOCUMENT_TYPE_NODE(10);
11.Node.DOCUMENT_FRAGMENT_NODE(11);
12.Node.NOTATION_NODE(12);
*/

/* 1)nodeType */
// IE8-中无效，IE未公开Node类型的构造函数。
if (SomeNode.nodeType === Node.ELEMENT_NODE) {
	alert("Node is an element.");
}
// 兼容方法
if (SomeNode.nodeType === 1) {
	alert("Node is an element.");
}
// 并不是所有节点类型都受到web浏览器的支持，最常用的就是元素和文本节点。

/* 2)nodeName & nodeValue */
// 对于元素节点，nodeName中保存的始终都是元素的标签名，nodeValue的值始终为null。
</textarea>
<p>
	节点间关系可以用家族关系来描述，相当于把文档树比喻成家谱。<br>
	每个节点都有一个childNodes属性，保存着一个NodeList对象。<br>
	（NodeList对象是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点<br>
	它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。）<br>
</p>
<textarea class="codemirror">
/* 3)childNodes */
var firstChild = someNode.childNodes[0];
var secondChild = someNode.childNodes.item(1);
var count = someNode.childNodes.length;

// 将NodeList对象转换成数组
function convertToArray(nodes){
	var arr = [];
	try{
		Array.prototype.slice.call(nodes, 0);
	}catch(e){
		for(var i = 0, len = nodes.length; i< len; i++){
			arr.push(nodes[i]);
		}
	};
	return arr;
}
// IE8及更早版本（IE8-）将NodeList对象实现为一个COM对象，所有必须动手枚举所有成员。


/*
	4)parentNode 父节点
	5)previousSibling 前一个邻居节点
	  nextSibling 后一个邻居节点
	注意：列表中的第一个节点的previousSibling为null，列表中的最后一个节点的nextSibling为null。
	6)firstChild & lastChild
	7)hasChildNodes() 
	返回boolean型值，查询节点是否有子节点，比childNodes列表的length属性更简单。

	注意：关系如图1。
*/
</textarea>
<h4>Document类型</h4>
<h4>Element类型</h4>
<h4>Text类型</h4>
<h4>Comment类型</h4>
<h4>CDATASection类型</h4>
<h4>DocumentType类型</h4>
<h4>DocumentFragment类型</h4>
<h4>Attr类型</h4>
<p>
	
</p>
<textarea class="codemirror">

</textarea>



<br>
<br>
<br>
<br>
<br>
<script src="../js/base.js"></script>
<p>图1</p>
<img src="../img/childNodes.png" alt="">
<p>参考：</p>
1.<a href="#" target="_blank"></a><br>
</body>

</html>
